# Documentation: `tools/rules/workspace.bzl`

## File Metadata

- **Path**: `tools/rules/workspace.bzl`
- **Size**: 1,882 bytes (1.84 KB)
- **Type**: Source File (.bzl)
- **Extension**: `.bzl`

## File Purpose

This file is a **utility or tool script**.

## Original Source

```
def _impl(repository_ctx):
    archive = repository_ctx.attr.name + ".tar"
    reference = Label("@%s_unpatched//:README" % repository_ctx.attr.name)
    dirname = repository_ctx.path(reference).dirname
    repository_ctx.execute(["tar", "hcf", archive, "-C", dirname, "."])
    repository_ctx.extract(archive)
    for patch in repository_ctx.attr.patches:
        repository_ctx.patch(repository_ctx.path(patch), repository_ctx.attr.patch_strip)
    build_file = repository_ctx.path(repository_ctx.attr.build_file)
    repository_ctx.execute(["cp", build_file, "BUILD.bazel"])

_patched_rule = repository_rule(
    implementation = _impl,
    attrs = {
        "build_file": attr.label(),
        "patch_strip": attr.int(),
        "patches": attr.label_list(),
    },
)

def new_patched_local_repository(name, path, **kwargs):
    native.new_local_repository(
        name = name + "_unpatched",
        build_file_content = """
pkg_tar(name = "content", srcs = glob(["**"]))
""",
        path = path,
    )
    _patched_rule(name = name, **kwargs)

def _new_empty_repository_impl(repo_ctx):
    build_file = repo_ctx.attr.build_file
    build_file_content = repo_ctx.attr.build_file_content
    if not (bool(build_file) != bool(build_file_content)):
        fail("Exactly one of 'build_file' or 'build_file_content' is required")

    if build_file_content:
        repo_ctx.file("BUILD", build_file_content)
    elif build_file:
        repo_ctx.template("BUILD", repo_ctx.attr.build_file, {})

new_empty_repository = repository_rule(
    attrs = {
        "build_file": attr.label(allow_files = True),
        "build_file_content": attr.string(),
    },
    implementation = _new_empty_repository_impl,
)

"""Create an empty repository with the supplied BUILD file.

This is mostly useful to create wrappers for specific target that we want
to be used with the '@' syntax.
"""

```



## High-Level Overview

This file is part of the PyTorch framework located at `tools/rules`.

## Detailed Analysis

### Code Structure


*For complete code details, see the Original Source section above.*


## Architecture & Design

### Role in PyTorch Architecture

This file is located in `tools/rules`, which contains **development tools and scripts**.



## Dependencies

### Import Dependencies

*Dependency analysis not applicable for this file type.*


## Code Patterns & Idioms

### Common Patterns

*No specific patterns automatically detected.*


## Performance Considerations

### Performance Notes


*Detailed performance analysis requires profiling and benchmarking.*


## Security & Safety

### Security Considerations

- No obvious security concerns detected in automated analysis.

*Manual security review is recommended for production code.*


## Testing & Usage

### Testing

Test files for this module may be located in the `test/` directory.

### Usage Examples

*See the source code and related test files for usage examples.*


## Related Files

### Related Files

Files in the same folder (`tools/rules`):

- [`cu.bzl_docs.md`](./cu.bzl_docs.md)


## Cross-References

- **File Documentation**: `workspace.bzl_docs.md`
- **Keyword Index**: `workspace.bzl_kw.md`
- **Folder Index**: `index.md`
- **Folder Documentation**: `doc.md`

---

*Generated by PyTorch Repository Documentation System*
