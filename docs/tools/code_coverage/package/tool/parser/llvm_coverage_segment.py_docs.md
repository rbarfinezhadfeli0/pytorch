# Documentation: llvm_coverage_segment.py

## File Metadata
- **Path**: `tools/code_coverage/package/tool/parser/llvm_coverage_segment.py`
- **Size**: 1975 bytes
- **Lines**: 62
- **Extension**: .py
- **Type**: Regular file

## Original Source

```py
from __future__ import annotations

from typing import NamedTuple


class LlvmCoverageSegment(NamedTuple):
    line: int
    col: int
    segment_count: int
    has_count: int
    is_region_entry: int
    is_gap_entry: int | None

    @property
    def has_coverage(self) -> bool:
        return self.segment_count > 0

    @property
    def is_executable(self) -> bool:
        return self.has_count > 0

    def get_coverage(
        self, prev_segment: LlvmCoverageSegment
    ) -> tuple[list[int], list[int]]:
        # Code adapted from testpilot.testinfra.runners.gtestcoveragerunner.py
        if not prev_segment.is_executable:
            return [], []

        # this segment ends at the line if col == 1
        # (so segment effectively ends on the line) and
        # line+1 if col is > 1 (so it touches at least some part of last line).
        end_of_segment = self.line if self.col == 1 else self.line + 1
        lines_range = list(range(prev_segment.line, end_of_segment))
        return (lines_range, []) if prev_segment.has_coverage else ([], lines_range)


def parse_segments(raw_segments: list[list[int]]) -> list[LlvmCoverageSegment]:
    """
    Creates LlvmCoverageSegment from a list of lists in llvm export json.
    each segment is represented by 5-element array.
    """
    ret: list[LlvmCoverageSegment] = []
    for raw_segment in raw_segments:
        assert len(raw_segment) == 5 or len(raw_segment) == 6, (
            "list is not compatible with llvmcom export:"
        )
        " Expected to have 5 or 6 elements"
        if len(raw_segment) == 5:
            ret.append(
                LlvmCoverageSegment(
                    raw_segment[0],
                    raw_segment[1],
                    raw_segment[2],
                    raw_segment[3],
                    raw_segment[4],
                    None,
                )
            )
        else:
            ret.append(LlvmCoverageSegment(*raw_segment))

    return ret

```

## High-Level Overview

This file is part of the PyTorch repository. It is a Python source file that may contain classes, functions, and module-level code.

## Detailed Walkthrough

### Classes
This file defines 1 class(es): LlvmCoverageSegment

### Functions
This file defines 4 function(s): has_coverage, is_executable, get_coverage, parse_segments


## Key Components

The file contains 198 words across 62 lines of code/text.

## Usage & Examples

This file is part of the larger PyTorch codebase. For usage examples, refer to related test files and documentation.

## Performance & Security Notes

- File size: 1975 bytes
- Complexity: Standard

## Related Files

See the folder index for related files in the same directory.

## Testing

Refer to the PyTorch test suite for test coverage of this file.

---
*Generated by Repo Book Generator v1.0*
