# Documentation: `docs/torch/csrc/utils/generated_serialization_types.h_docs.md`

## File Metadata

- **Path**: `docs/torch/csrc/utils/generated_serialization_types.h_docs.md`
- **Size**: 52,853 bytes (51.61 KB)
- **Type**: Markdown Documentation
- **Extension**: `.md`

## File Purpose

This file is part of the **documentation**.

## Original Source

```markdown
# Documentation: `torch/csrc/utils/generated_serialization_types.h`

## File Metadata

- **Path**: `torch/csrc/utils/generated_serialization_types.h`
- **Size**: 120,273 bytes (117.45 KB)
- **Type**: C/C++ Header File
- **Extension**: `.h`

## File Purpose

This is a c/c++ header file that is part of the PyTorch project.

## Original Source

```c
// @generated by update_schema.py
// checksum<<74d07b92c36d5854263145c231553dcda15215f0460e7ace43554248c05378ec>>
// clang-format off

#pragma once

#include <optional>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <variant>
#include <vector>
#include <c10/util/Exception.h>

#include <nlohmann/json.hpp>

#ifndef NLOHMANN_JSON_NAMESPACE_BEGIN
#define NLOHMANN_JSON_NAMESPACE_BEGIN namespace nlohmann {
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_END
#define NLOHMANN_JSON_NAMESPACE_END }
#endif

// https://github.com/nlohmann/json/pull/2117
NLOHMANN_JSON_NAMESPACE_BEGIN
template <typename T>
struct adl_serializer<std::optional<T>> {
  static void to_json(json& j, const std::optional<T>& opt) {
    if (opt == std::nullopt) {
      j = nullptr;
    } else {
      j = *opt; // this will call adl_serializer<T>::to_json which will
                // find the free function to_json in T's namespace!
    }
  }

  static void from_json(const json& j, std::optional<T>& opt) {
    if (j.is_null()) {
      opt = std::nullopt;
    } else {
      opt = j.template get<T>(); // same as above, but with
                                 // adl_serializer<T>::from_json
    }
  }
};
NLOHMANN_JSON_NAMESPACE_END

namespace torch {
namespace _export {

template <typename T>
class ForwardRef {
  static_assert(!std::is_reference_v<T>, "ForwardRef cannot be a reference type");

 public:
  ForwardRef(): ptr_(std::make_unique<T>()) {}
  ForwardRef(ForwardRef<T>&&);
  ForwardRef(const ForwardRef<T>& other): ptr_(std::make_unique<T>(*other.ptr_)) {}
  ForwardRef<T>& operator=(ForwardRef<T>&&);
  ForwardRef<T>& operator=(const ForwardRef<T>& other) {
    ptr_ = std::make_unique<T>(*other.ptr_);
    return *this;
  }
  ~ForwardRef();
  const T& operator*() const {
    return *ptr_;
  }

  const T* operator->() const {
    return ptr_.get();
  }

  void emplace(T&& t) {
    ptr_ = std::make_unique<T>(std::move(t));
  }

 private:
  std::unique_ptr<T> ptr_;
};

template <typename T>
void to_json(nlohmann::json& j, const ForwardRef<T>& p) {
  j = *p;
}

template <typename T>
void from_json(const nlohmann::json& j, ForwardRef<T>& p) {
  p.emplace(j.template get<T>());
}

class F64 {
 public:
  double get() const {
    return value_;
  }

  void set(double value) {
    value_ = value;
  }

 private:
  double value_;
};

inline void to_json(nlohmann::json& j, const F64& f) {
  if (std::isinf(f.get())) {
    j = "Infinity";
  } else if (std::isinf(-f.get())) {
    j = "-Infinity";
  } else if (std::isnan(f.get())) {
    j = "NaN";
  } else {
    j = f.get();
  }
}

inline void from_json(const nlohmann::json& j, F64& f) {
  if (j == "Infinity") {
    f.set(std::numeric_limits<double>::infinity());
  } else if (j == "-Infinity") {
    f.set(-std::numeric_limits<double>::infinity());
  } else if (j == "NaN") {
    f.set(std::numeric_limits<double>::quiet_NaN());
  } else {
    f.set(j.get<double>());
  }
}

class AOTInductorModelPickleData;
class Argument;
class BufferMutationSpec;
class ComplexValue;
class ConstantValue;
class CustomObjArgument;
class Device;
class ExportedProgram;
class ExternKernelNode;
class ExternKernelNodes;
class GradientToParameterSpec;
class GradientToUserInputSpec;
class Graph;
class GraphArgument;
class GraphModule;
class GraphSignature;
class InputSpec;
class InputToBufferSpec;
class InputToConstantInputSpec;
class InputToCustomObjSpec;
class InputToParameterSpec;
class InputToTensorConstantSpec;
class InputTokenSpec;
class LossOutputSpec;
class ModuleCallEntry;
class ModuleCallSignature;
class NamedArgument;
class NamedTupleDef;
class Node;
class OptionalTensorArgument;
class OutputSpec;
class OutputTokenSpec;
class ParameterMutationSpec;
class PayloadConfig;
class PayloadMeta;
class RangeConstraint;
class SchemaVersion;
class SymBool;
class SymBoolArgument;
class SymExpr;
class SymExprHint;
class SymFloat;
class SymFloatArgument;
class SymInt;
class SymIntArgument;
class TensorArgument;
class TensorMeta;
class TokenArgument;
class UserInputMutationSpec;
class UserInputSpec;
class UserOutputSpec;

enum class ArgumentKind {
  UNKNOWN = 0,
  POSITIONAL = 1,
  KEYWORD = 2,
};

inline std::string_view printEnum(const ArgumentKind& e) {
  switch (e) {
    case ArgumentKind::UNKNOWN: return "UNKNOWN";
    case ArgumentKind::POSITIONAL: return "POSITIONAL";
    case ArgumentKind::KEYWORD: return "KEYWORD";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, ArgumentKind& t) {
  if (s == "UNKNOWN") { t = ArgumentKind::UNKNOWN; return; }
  if (s == "POSITIONAL") { t = ArgumentKind::POSITIONAL; return; }
  if (s == "KEYWORD") { t = ArgumentKind::KEYWORD; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}

enum class Layout {
  Unknown = 0,
  SparseCoo = 1,
  SparseCsr = 2,
  SparseCsc = 3,
  SparseBsr = 4,
  SparseBsc = 5,
  _mkldnn = 6,
  Strided = 7,
};

inline std::string_view printEnum(const Layout& e) {
  switch (e) {
    case Layout::Unknown: return "Unknown";
    case Layout::SparseCoo: return "SparseCoo";
    case Layout::SparseCsr: return "SparseCsr";
    case Layout::SparseCsc: return "SparseCsc";
    case Layout::SparseBsr: return "SparseBsr";
    case Layout::SparseBsc: return "SparseBsc";
    case Layout::_mkldnn: return "_mkldnn";
    case Layout::Strided: return "Strided";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, Layout& t) {
  if (s == "Unknown") { t = Layout::Unknown; return; }
  if (s == "SparseCoo") { t = Layout::SparseCoo; return; }
  if (s == "SparseCsr") { t = Layout::SparseCsr; return; }
  if (s == "SparseCsc") { t = Layout::SparseCsc; return; }
  if (s == "SparseBsr") { t = Layout::SparseBsr; return; }
  if (s == "SparseBsc") { t = Layout::SparseBsc; return; }
  if (s == "_mkldnn") { t = Layout::_mkldnn; return; }
  if (s == "Strided") { t = Layout::Strided; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}

enum class MemoryFormat {
  Unknown = 0,
  ContiguousFormat = 1,
  ChannelsLast = 2,
  ChannelsLast3d = 3,
  PreserveFormat = 4,
};

inline std::string_view printEnum(const MemoryFormat& e) {
  switch (e) {
    case MemoryFormat::Unknown: return "Unknown";
    case MemoryFormat::ContiguousFormat: return "ContiguousFormat";
    case MemoryFormat::ChannelsLast: return "ChannelsLast";
    case MemoryFormat::ChannelsLast3d: return "ChannelsLast3d";
    case MemoryFormat::PreserveFormat: return "PreserveFormat";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, MemoryFormat& t) {
  if (s == "Unknown") { t = MemoryFormat::Unknown; return; }
  if (s == "ContiguousFormat") { t = MemoryFormat::ContiguousFormat; return; }
  if (s == "ChannelsLast") { t = MemoryFormat::ChannelsLast; return; }
  if (s == "ChannelsLast3d") { t = MemoryFormat::ChannelsLast3d; return; }
  if (s == "PreserveFormat") { t = MemoryFormat::PreserveFormat; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}

enum class ScalarType {
  UNKNOWN = 0,
  BYTE = 1,
  CHAR = 2,
  SHORT = 3,
  INT = 4,
  LONG = 5,
  HALF = 6,
  FLOAT = 7,
  DOUBLE = 8,
  COMPLEXHALF = 9,
  COMPLEXFLOAT = 10,
  COMPLEXDOUBLE = 11,
  BOOL = 12,
  BFLOAT16 = 13,
  UINT16 = 28,
  FLOAT8E4M3FN = 29,
  FLOAT8E5M2 = 30,
  FLOAT8E4M3FNUZ = 31,
  FLOAT8E5M2FNUZ = 32,
};

inline std::string_view printEnum(const ScalarType& e) {
  switch (e) {
    case ScalarType::UNKNOWN: return "UNKNOWN";
    case ScalarType::BYTE: return "BYTE";
    case ScalarType::CHAR: return "CHAR";
    case ScalarType::SHORT: return "SHORT";
    case ScalarType::INT: return "INT";
    case ScalarType::LONG: return "LONG";
    case ScalarType::HALF: return "HALF";
    case ScalarType::FLOAT: return "FLOAT";
    case ScalarType::DOUBLE: return "DOUBLE";
    case ScalarType::COMPLEXHALF: return "COMPLEXHALF";
    case ScalarType::COMPLEXFLOAT: return "COMPLEXFLOAT";
    case ScalarType::COMPLEXDOUBLE: return "COMPLEXDOUBLE";
    case ScalarType::BOOL: return "BOOL";
    case ScalarType::BFLOAT16: return "BFLOAT16";
    case ScalarType::UINT16: return "UINT16";
    case ScalarType::FLOAT8E4M3FN: return "FLOAT8E4M3FN";
    case ScalarType::FLOAT8E5M2: return "FLOAT8E5M2";
    case ScalarType::FLOAT8E4M3FNUZ: return "FLOAT8E4M3FNUZ";
    case ScalarType::FLOAT8E5M2FNUZ: return "FLOAT8E5M2FNUZ";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, ScalarType& t) {
  if (s == "UNKNOWN") { t = ScalarType::UNKNOWN; return; }
  if (s == "BYTE") { t = ScalarType::BYTE; return; }
  if (s == "CHAR") { t = ScalarType::CHAR; return; }
  if (s == "SHORT") { t = ScalarType::SHORT; return; }
  if (s == "INT") { t = ScalarType::INT; return; }
  if (s == "LONG") { t = ScalarType::LONG; return; }
  if (s == "HALF") { t = ScalarType::HALF; return; }
  if (s == "FLOAT") { t = ScalarType::FLOAT; return; }
  if (s == "DOUBLE") { t = ScalarType::DOUBLE; return; }
  if (s == "COMPLEXHALF") { t = ScalarType::COMPLEXHALF; return; }
  if (s == "COMPLEXFLOAT") { t = ScalarType::COMPLEXFLOAT; return; }
  if (s == "COMPLEXDOUBLE") { t = ScalarType::COMPLEXDOUBLE; return; }
  if (s == "BOOL") { t = ScalarType::BOOL; return; }
  if (s == "BFLOAT16") { t = ScalarType::BFLOAT16; return; }
  if (s == "UINT16") { t = ScalarType::UINT16; return; }
  if (s == "FLOAT8E4M3FN") { t = ScalarType::FLOAT8E4M3FN; return; }
  if (s == "FLOAT8E5M2") { t = ScalarType::FLOAT8E5M2; return; }
  if (s == "FLOAT8E4M3FNUZ") { t = ScalarType::FLOAT8E4M3FNUZ; return; }
  if (s == "FLOAT8E5M2FNUZ") { t = ScalarType::FLOAT8E5M2FNUZ; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class Device {
 private:
  std::string type;
  std::optional<int64_t> index = std::nullopt;

 public:

  const std::string& get_type() const {
    return type;
  }

  void set_type(std::string def) {
    type = std::move(def);
  }

  const std::optional<int64_t>& get_index() const {
    return index;
  }

  void set_index(std::optional<int64_t> def) {
    index = std::move(def);
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const Device& nlohmann_json_t);
  friend void from_json(const nlohmann::json& nlohmann_json_j, Device& nlohmann_json_t);
};

class SymExprHint {
  struct Void {};

 public:
  enum class Tag {
    AS_INT, AS_BOOL, AS_FLOAT
  };

 private:
  std::variant<Void, int64_t, bool, F64> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const int64_t& get_as_int() const {
    return std::get<1>(variant_);
  }

  void set_as_int(int64_t def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_INT;
  }

  const bool& get_as_bool() const {
    return std::get<2>(variant_);
  }

  void set_as_bool(bool def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_BOOL;
  }

  const F64& get_as_float() const {
    return std::get<3>(variant_);
  }

  void set_as_float(F64 def) {
    variant_.emplace<3>(std::move(def));
    tag_ = Tag::AS_FLOAT;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const SymExprHint& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_INT) {
      nlohmann_json_j["as_int"] = nlohmann_json_t.get_as_int();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_BOOL) {
      nlohmann_json_j["as_bool"] = nlohmann_json_t.get_as_bool();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_FLOAT) {
      nlohmann_json_j["as_float"] = nlohmann_json_t.get_as_float();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, SymExprHint& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_int")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_int").template get<int64_t>());
      nlohmann_json_t.tag_ = Tag::AS_INT;
      return;
    }
    if (nlohmann_json_j.contains("as_bool")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_bool").template get<bool>());
      nlohmann_json_t.tag_ = Tag::AS_BOOL;
      return;
    }
    if (nlohmann_json_j.contains("as_float")) {
      nlohmann_json_t.variant_.emplace<3>(nlohmann_json_j.at("as_float").template get<F64>());
      nlohmann_json_t.tag_ = Tag::AS_FLOAT;
      return;
    }
  }
};

inline std::string_view printEnum(const SymExprHint::Tag& e) {
  switch (e) {
    case SymExprHint::Tag::AS_INT: return "AS_INT";
    case SymExprHint::Tag::AS_BOOL: return "AS_BOOL";
    case SymExprHint::Tag::AS_FLOAT: return "AS_FLOAT";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, SymExprHint::Tag& t) {
  if (s == "AS_INT") { t = SymExprHint::Tag::AS_INT; return; }
  if (s == "AS_BOOL") { t = SymExprHint::Tag::AS_BOOL; return; }
  if (s == "AS_FLOAT") { t = SymExprHint::Tag::AS_FLOAT; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class SymExpr {
 private:
  std::string expr_str;
  std::optional<SymExprHint> hint = std::nullopt;

 public:

  const std::string& get_expr_str() const {
    return expr_str;
  }

  void set_expr_str(std::string def) {
    expr_str = std::move(def);
  }

  const std::optional<SymExprHint>& get_hint() const {
    return hint;
  }

  void set_hint(std::optional<SymExprHint> def) {
    hint = std::move(def);
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const SymExpr& nlohmann_json_t);
  friend void from_json(const nlohmann::json& nlohmann_json_j, SymExpr& nlohmann_json_t);
};

class SymInt {
  struct Void {};

 public:
  enum class Tag {
    AS_EXPR, AS_INT
  };

 private:
  std::variant<Void, SymExpr, int64_t> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const SymExpr& get_as_expr() const {
    return std::get<1>(variant_);
  }

  void set_as_expr(SymExpr def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_EXPR;
  }

  const int64_t& get_as_int() const {
    return std::get<2>(variant_);
  }

  void set_as_int(int64_t def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_INT;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const SymInt& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_EXPR) {
      nlohmann_json_j["as_expr"] = nlohmann_json_t.get_as_expr();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_INT) {
      nlohmann_json_j["as_int"] = nlohmann_json_t.get_as_int();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, SymInt& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_expr")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_expr").template get<SymExpr>());
      nlohmann_json_t.tag_ = Tag::AS_EXPR;
      return;
    }
    if (nlohmann_json_j.contains("as_int")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_int").template get<int64_t>());
      nlohmann_json_t.tag_ = Tag::AS_INT;
      return;
    }
  }
};

inline std::string_view printEnum(const SymInt::Tag& e) {
  switch (e) {
    case SymInt::Tag::AS_EXPR: return "AS_EXPR";
    case SymInt::Tag::AS_INT: return "AS_INT";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, SymInt::Tag& t) {
  if (s == "AS_EXPR") { t = SymInt::Tag::AS_EXPR; return; }
  if (s == "AS_INT") { t = SymInt::Tag::AS_INT; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class SymFloat {
  struct Void {};

 public:
  enum class Tag {
    AS_EXPR, AS_FLOAT
  };

 private:
  std::variant<Void, SymExpr, F64> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const SymExpr& get_as_expr() const {
    return std::get<1>(variant_);
  }

  void set_as_expr(SymExpr def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_EXPR;
  }

  const F64& get_as_float() const {
    return std::get<2>(variant_);
  }

  void set_as_float(F64 def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_FLOAT;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const SymFloat& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_EXPR) {
      nlohmann_json_j["as_expr"] = nlohmann_json_t.get_as_expr();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_FLOAT) {
      nlohmann_json_j["as_float"] = nlohmann_json_t.get_as_float();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, SymFloat& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_expr")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_expr").template get<SymExpr>());
      nlohmann_json_t.tag_ = Tag::AS_EXPR;
      return;
    }
    if (nlohmann_json_j.contains("as_float")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_float").template get<F64>());
      nlohmann_json_t.tag_ = Tag::AS_FLOAT;
      return;
    }
  }
};

inline std::string_view printEnum(const SymFloat::Tag& e) {
  switch (e) {
    case SymFloat::Tag::AS_EXPR: return "AS_EXPR";
    case SymFloat::Tag::AS_FLOAT: return "AS_FLOAT";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, SymFloat::Tag& t) {
  if (s == "AS_EXPR") { t = SymFloat::Tag::AS_EXPR; return; }
  if (s == "AS_FLOAT") { t = SymFloat::Tag::AS_FLOAT; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class SymBool {
  struct Void {};

 public:
  enum class Tag {
    AS_EXPR, AS_BOOL
  };

 private:
  std::variant<Void, SymExpr, bool> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const SymExpr& get_as_expr() const {
    return std::get<1>(variant_);
  }

  void set_as_expr(SymExpr def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_EXPR;
  }

  const bool& get_as_bool() const {
    return std::get<2>(variant_);
  }

  void set_as_bool(bool def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_BOOL;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const SymBool& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_EXPR) {
      nlohmann_json_j["as_expr"] = nlohmann_json_t.get_as_expr();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_BOOL) {
      nlohmann_json_j["as_bool"] = nlohmann_json_t.get_as_bool();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, SymBool& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_expr")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_expr").template get<SymExpr>());
      nlohmann_json_t.tag_ = Tag::AS_EXPR;
      return;
    }
    if (nlohmann_json_j.contains("as_bool")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_bool").template get<bool>());
      nlohmann_json_t.tag_ = Tag::AS_BOOL;
      return;
    }
  }
};

inline std::string_view printEnum(const SymBool::Tag& e) {
  switch (e) {
    case SymBool::Tag::AS_EXPR: return "AS_EXPR";
    case SymBool::Tag::AS_BOOL: return "AS_BOOL";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, SymBool::Tag& t) {
  if (s == "AS_EXPR") { t = SymBool::Tag::AS_EXPR; return; }
  if (s == "AS_BOOL") { t = SymBool::Tag::AS_BOOL; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class TensorMeta {
 private:
  int64_t dtype;
  std::vector<SymInt> sizes;
  bool requires_grad;
  Device device;
  std::vector<SymInt> strides;
  SymInt storage_offset;
  int64_t layout;

 public:

  ScalarType get_dtype() const {
    return static_cast<ScalarType>(dtype);
  }

  void set_dtype(ScalarType def) {
    dtype = static_cast<int64_t>(def);
  }

  const std::vector<SymInt>& get_sizes() const {
    return sizes;
  }

  void set_sizes(std::vector<SymInt> def) {
    sizes = std::move(def);
  }

  const bool& get_requires_grad() const {
    return requires_grad;
  }

  void set_requires_grad(bool def) {
    requires_grad = std::move(def);
  }

  const Device& get_device() const {
    return device;
  }

  void set_device(Device def) {
    device = std::move(def);
  }

  const std::vector<SymInt>& get_strides() const {
    return strides;
  }

  void set_strides(std::vector<SymInt> def) {
    strides = std::move(def);
  }

  const SymInt& get_storage_offset() const {
    return storage_offset;
  }

  void set_storage_offset(SymInt def) {
    storage_offset = std::move(def);
  }

  Layout get_layout() const {
    return static_cast<Layout>(layout);
  }

  void set_layout(Layout def) {
    layout = static_cast<int64_t>(def);
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const TensorMeta& nlohmann_json_t);
  friend void from_json(const nlohmann::json& nlohmann_json_j, TensorMeta& nlohmann_json_t);
};

class SymIntArgument {
  struct Void {};

 public:
  enum class Tag {
    AS_NAME, AS_INT
  };

 private:
  std::variant<Void, std::string, int64_t> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const std::string& get_as_name() const {
    return std::get<1>(variant_);
  }

  void set_as_name(std::string def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_NAME;
  }

  const int64_t& get_as_int() const {
    return std::get<2>(variant_);
  }

  void set_as_int(int64_t def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_INT;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const SymIntArgument& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_NAME) {
      nlohmann_json_j["as_name"] = nlohmann_json_t.get_as_name();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_INT) {
      nlohmann_json_j["as_int"] = nlohmann_json_t.get_as_int();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, SymIntArgument& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_name")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_name").template get<std::string>());
      nlohmann_json_t.tag_ = Tag::AS_NAME;
      return;
    }
    if (nlohmann_json_j.contains("as_int")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_int").template get<int64_t>());
      nlohmann_json_t.tag_ = Tag::AS_INT;
      return;
    }
  }
};

inline std::string_view printEnum(const SymIntArgument::Tag& e) {
  switch (e) {
    case SymIntArgument::Tag::AS_NAME: return "AS_NAME";
    case SymIntArgument::Tag::AS_INT: return "AS_INT";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, SymIntArgument::Tag& t) {
  if (s == "AS_NAME") { t = SymIntArgument::Tag::AS_NAME; return; }
  if (s == "AS_INT") { t = SymIntArgument::Tag::AS_INT; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class SymFloatArgument {
  struct Void {};

 public:
  enum class Tag {
    AS_NAME, AS_FLOAT
  };

 private:
  std::variant<Void, std::string, F64> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const std::string& get_as_name() const {
    return std::get<1>(variant_);
  }

  void set_as_name(std::string def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_NAME;
  }

  const F64& get_as_float() const {
    return std::get<2>(variant_);
  }

  void set_as_float(F64 def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_FLOAT;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const SymFloatArgument& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_NAME) {
      nlohmann_json_j["as_name"] = nlohmann_json_t.get_as_name();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_FLOAT) {
      nlohmann_json_j["as_float"] = nlohmann_json_t.get_as_float();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, SymFloatArgument& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_name")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_name").template get<std::string>());
      nlohmann_json_t.tag_ = Tag::AS_NAME;
      return;
    }
    if (nlohmann_json_j.contains("as_float")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_float").template get<F64>());
      nlohmann_json_t.tag_ = Tag::AS_FLOAT;
      return;
    }
  }
};

inline std::string_view printEnum(const SymFloatArgument::Tag& e) {
  switch (e) {
    case SymFloatArgument::Tag::AS_NAME: return "AS_NAME";
    case SymFloatArgument::Tag::AS_FLOAT: return "AS_FLOAT";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, SymFloatArgument::Tag& t) {
  if (s == "AS_NAME") { t = SymFloatArgument::Tag::AS_NAME; return; }
  if (s == "AS_FLOAT") { t = SymFloatArgument::Tag::AS_FLOAT; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class SymBoolArgument {
  struct Void {};

 public:
  enum class Tag {
    AS_NAME, AS_BOOL
  };

 private:
  std::variant<Void, std::string, bool> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const std::string& get_as_name() const {
    return std::get<1>(variant_);
  }

  void set_as_name(std::string def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_NAME;
  }

  const bool& get_as_bool() const {
    return std::get<2>(variant_);
  }

  void set_as_bool(bool def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_BOOL;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const SymBoolArgument& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_NAME) {
      nlohmann_json_j["as_name"] = nlohmann_json_t.get_as_name();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_BOOL) {
      nlohmann_json_j["as_bool"] = nlohmann_json_t.get_as_bool();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, SymBoolArgument& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_name")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_name").template get<std::string>());
      nlohmann_json_t.tag_ = Tag::AS_NAME;
      return;
    }
    if (nlohmann_json_j.contains("as_bool")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_bool").template get<bool>());
      nlohmann_json_t.tag_ = Tag::AS_BOOL;
      return;
    }
  }
};

inline std::string_view printEnum(const SymBoolArgument::Tag& e) {
  switch (e) {
    case SymBoolArgument::Tag::AS_NAME: return "AS_NAME";
    case SymBoolArgument::Tag::AS_BOOL: return "AS_BOOL";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, SymBoolArgument::Tag& t) {
  if (s == "AS_NAME") { t = SymBoolArgument::Tag::AS_NAME; return; }
  if (s == "AS_BOOL") { t = SymBoolArgument::Tag::AS_BOOL; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class TensorArgument {
 private:
  std::string name;

 public:

  const std::string& get_name() const {
    return name;
  }

  void set_name(std::string def) {
    name = std::move(def);
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const TensorArgument& nlohmann_json_t);
  friend void from_json(const nlohmann::json& nlohmann_json_j, TensorArgument& nlohmann_json_t);
};

class TokenArgument {
 private:
  std::string name;

 public:

  const std::string& get_name() const {
    return name;
  }

  void set_name(std::string def) {
    name = std::move(def);
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const TokenArgument& nlohmann_json_t);
  friend void from_json(const nlohmann::json& nlohmann_json_j, TokenArgument& nlohmann_json_t);
};

class OptionalTensorArgument {
  struct Void {};

 public:
  enum class Tag {
    AS_TENSOR, AS_NONE
  };

 private:
  std::variant<Void, TensorArgument, bool> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const TensorArgument& get_as_tensor() const {
    return std::get<1>(variant_);
  }

  void set_as_tensor(TensorArgument def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_TENSOR;
  }

  const bool& get_as_none() const {
    return std::get<2>(variant_);
  }

  void set_as_none(bool def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_NONE;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const OptionalTensorArgument& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_TENSOR) {
      nlohmann_json_j["as_tensor"] = nlohmann_json_t.get_as_tensor();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_NONE) {
      nlohmann_json_j["as_none"] = nlohmann_json_t.get_as_none();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, OptionalTensorArgument& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_tensor")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_tensor").template get<TensorArgument>());
      nlohmann_json_t.tag_ = Tag::AS_TENSOR;
      return;
    }
    if (nlohmann_json_j.contains("as_none")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_none").template get<bool>());
      nlohmann_json_t.tag_ = Tag::AS_NONE;
      return;
    }
  }
};

inline std::string_view printEnum(const OptionalTensorArgument::Tag& e) {
  switch (e) {
    case OptionalTensorArgument::Tag::AS_TENSOR: return "AS_TENSOR";
    case OptionalTensorArgument::Tag::AS_NONE: return "AS_NONE";
    default:
      TORCH_CHECK(false, "Unknown enum value");
  }
}

inline void parseEnum(std::string_view s, OptionalTensorArgument::Tag& t) {
  if (s == "AS_TENSOR") { t = OptionalTensorArgument::Tag::AS_TENSOR; return; }
  if (s == "AS_NONE") { t = OptionalTensorArgument::Tag::AS_NONE; return; }
  TORCH_CHECK(false, "Unknown enum value: " + std::string{s});
}


class GraphArgument {
 private:
  std::string name;
  ForwardRef<Graph> graph;

 public:

  const std::string& get_name() const {
    return name;
  }

  void set_name(std::string def) {
    name = std::move(def);
  }

  const ForwardRef<Graph>& get_graph() const {
    return graph;
  }

  void set_graph(ForwardRef<Graph> def) {
    graph = std::move(def);
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const GraphArgument& nlohmann_json_t);
  friend void from_json(const nlohmann::json& nlohmann_json_j, GraphArgument& nlohmann_json_t);
};

class CustomObjArgument {
 private:
  std::string name;
  std::string class_fqn;

 public:

  const std::string& get_name() const {
    return name;
  }

  void set_name(std::string def) {
    name = std::move(def);
  }

  const std::string& get_class_fqn() const {
    return class_fqn;
  }

  void set_class_fqn(std::string def) {
    class_fqn = std::move(def);
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const CustomObjArgument& nlohmann_json_t);
  friend void from_json(const nlohmann::json& nlohmann_json_j, CustomObjArgument& nlohmann_json_t);
};

class ComplexValue {
 private:
  F64 real;
  F64 imag;

 public:

  const F64& get_real() const {
    return real;
  }

  void set_real(F64 def) {
    real = std::move(def);
  }

  const F64& get_imag() const {
    return imag;
  }

  void set_imag(F64 def) {
    imag = std::move(def);
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const ComplexValue& nlohmann_json_t);
  friend void from_json(const nlohmann::json& nlohmann_json_j, ComplexValue& nlohmann_json_t);
};

class Argument {
  struct Void {};

 public:
  enum class Tag {
    AS_NONE, AS_TENSOR, AS_TENSORS, AS_INT, AS_INTS, AS_FLOAT, AS_FLOATS, AS_STRING, AS_STRINGS, AS_SYM_INT, AS_SYM_INTS, AS_SCALAR_TYPE, AS_MEMORY_FORMAT, AS_LAYOUT, AS_DEVICE, AS_BOOL, AS_BOOLS, AS_SYM_BOOL, AS_SYM_BOOLS, AS_GRAPH, AS_OPTIONAL_TENSORS, AS_CUSTOM_OBJ, AS_OPERATOR, AS_SYM_FLOAT, AS_SYM_FLOATS, AS_OPTIONAL_TENSOR, AS_COMPLEX
  };

 private:
  std::variant<Void, bool, TensorArgument, std::vector<TensorArgument>, int64_t, std::vector<int64_t>, F64, std::vector<F64>, std::string, std::vector<std::string>, SymIntArgument, std::vector<SymIntArgument>, ScalarType, MemoryFormat, Layout, Device, bool, std::vector<bool>, SymBoolArgument, std::vector<SymBoolArgument>, GraphArgument, std::vector<OptionalTensorArgument>, CustomObjArgument, std::string, SymFloatArgument, std::vector<SymFloatArgument>, OptionalTensorArgument, ComplexValue> variant_;
  Tag tag_;

 public:
  Tag tag() const {
    return tag_;
  }

  const bool& get_as_none() const {
    return std::get<1>(variant_);
  }

  void set_as_none(bool def) {
    variant_.emplace<1>(std::move(def));
    tag_ = Tag::AS_NONE;
  }

  const TensorArgument& get_as_tensor() const {
    return std::get<2>(variant_);
  }

  void set_as_tensor(TensorArgument def) {
    variant_.emplace<2>(std::move(def));
    tag_ = Tag::AS_TENSOR;
  }

  const std::vector<TensorArgument>& get_as_tensors() const {
    return std::get<3>(variant_);
  }

  void set_as_tensors(std::vector<TensorArgument> def) {
    variant_.emplace<3>(std::move(def));
    tag_ = Tag::AS_TENSORS;
  }

  const int64_t& get_as_int() const {
    return std::get<4>(variant_);
  }

  void set_as_int(int64_t def) {
    variant_.emplace<4>(std::move(def));
    tag_ = Tag::AS_INT;
  }

  const std::vector<int64_t>& get_as_ints() const {
    return std::get<5>(variant_);
  }

  void set_as_ints(std::vector<int64_t> def) {
    variant_.emplace<5>(std::move(def));
    tag_ = Tag::AS_INTS;
  }

  const F64& get_as_float() const {
    return std::get<6>(variant_);
  }

  void set_as_float(F64 def) {
    variant_.emplace<6>(std::move(def));
    tag_ = Tag::AS_FLOAT;
  }

  const std::vector<F64>& get_as_floats() const {
    return std::get<7>(variant_);
  }

  void set_as_floats(std::vector<F64> def) {
    variant_.emplace<7>(std::move(def));
    tag_ = Tag::AS_FLOATS;
  }

  const std::string& get_as_string() const {
    return std::get<8>(variant_);
  }

  void set_as_string(std::string def) {
    variant_.emplace<8>(std::move(def));
    tag_ = Tag::AS_STRING;
  }

  const std::vector<std::string>& get_as_strings() const {
    return std::get<9>(variant_);
  }

  void set_as_strings(std::vector<std::string> def) {
    variant_.emplace<9>(std::move(def));
    tag_ = Tag::AS_STRINGS;
  }

  const SymIntArgument& get_as_sym_int() const {
    return std::get<10>(variant_);
  }

  void set_as_sym_int(SymIntArgument def) {
    variant_.emplace<10>(std::move(def));
    tag_ = Tag::AS_SYM_INT;
  }

  const std::vector<SymIntArgument>& get_as_sym_ints() const {
    return std::get<11>(variant_);
  }

  void set_as_sym_ints(std::vector<SymIntArgument> def) {
    variant_.emplace<11>(std::move(def));
    tag_ = Tag::AS_SYM_INTS;
  }

  const ScalarType& get_as_scalar_type() const {
    return std::get<12>(variant_);
  }

  void set_as_scalar_type(ScalarType def) {
    variant_.emplace<12>(std::move(def));
    tag_ = Tag::AS_SCALAR_TYPE;
  }

  const MemoryFormat& get_as_memory_format() const {
    return std::get<13>(variant_);
  }

  void set_as_memory_format(MemoryFormat def) {
    variant_.emplace<13>(std::move(def));
    tag_ = Tag::AS_MEMORY_FORMAT;
  }

  const Layout& get_as_layout() const {
    return std::get<14>(variant_);
  }

  void set_as_layout(Layout def) {
    variant_.emplace<14>(std::move(def));
    tag_ = Tag::AS_LAYOUT;
  }

  const Device& get_as_device() const {
    return std::get<15>(variant_);
  }

  void set_as_device(Device def) {
    variant_.emplace<15>(std::move(def));
    tag_ = Tag::AS_DEVICE;
  }

  const bool& get_as_bool() const {
    return std::get<16>(variant_);
  }

  void set_as_bool(bool def) {
    variant_.emplace<16>(std::move(def));
    tag_ = Tag::AS_BOOL;
  }

  const std::vector<bool>& get_as_bools() const {
    return std::get<17>(variant_);
  }

  void set_as_bools(std::vector<bool> def) {
    variant_.emplace<17>(std::move(def));
    tag_ = Tag::AS_BOOLS;
  }

  const SymBoolArgument& get_as_sym_bool() const {
    return std::get<18>(variant_);
  }

  void set_as_sym_bool(SymBoolArgument def) {
    variant_.emplace<18>(std::move(def));
    tag_ = Tag::AS_SYM_BOOL;
  }

  const std::vector<SymBoolArgument>& get_as_sym_bools() const {
    return std::get<19>(variant_);
  }

  void set_as_sym_bools(std::vector<SymBoolArgument> def) {
    variant_.emplace<19>(std::move(def));
    tag_ = Tag::AS_SYM_BOOLS;
  }

  const GraphArgument& get_as_graph() const {
    return std::get<20>(variant_);
  }

  void set_as_graph(GraphArgument def) {
    variant_.emplace<20>(std::move(def));
    tag_ = Tag::AS_GRAPH;
  }

  const std::vector<OptionalTensorArgument>& get_as_optional_tensors() const {
    return std::get<21>(variant_);
  }

  void set_as_optional_tensors(std::vector<OptionalTensorArgument> def) {
    variant_.emplace<21>(std::move(def));
    tag_ = Tag::AS_OPTIONAL_TENSORS;
  }

  const CustomObjArgument& get_as_custom_obj() const {
    return std::get<22>(variant_);
  }

  void set_as_custom_obj(CustomObjArgument def) {
    variant_.emplace<22>(std::move(def));
    tag_ = Tag::AS_CUSTOM_OBJ;
  }

  const std::string& get_as_operator() const {
    return std::get<23>(variant_);
  }

  void set_as_operator(std::string def) {
    variant_.emplace<23>(std::move(def));
    tag_ = Tag::AS_OPERATOR;
  }

  const SymFloatArgument& get_as_sym_float() const {
    return std::get<24>(variant_);
  }

  void set_as_sym_float(SymFloatArgument def) {
    variant_.emplace<24>(std::move(def));
    tag_ = Tag::AS_SYM_FLOAT;
  }

  const std::vector<SymFloatArgument>& get_as_sym_floats() const {
    return std::get<25>(variant_);
  }

  void set_as_sym_floats(std::vector<SymFloatArgument> def) {
    variant_.emplace<25>(std::move(def));
    tag_ = Tag::AS_SYM_FLOATS;
  }

  const OptionalTensorArgument& get_as_optional_tensor() const {
    return std::get<26>(variant_);
  }

  void set_as_optional_tensor(OptionalTensorArgument def) {
    variant_.emplace<26>(std::move(def));
    tag_ = Tag::AS_OPTIONAL_TENSOR;
  }

  const ComplexValue& get_as_complex() const {
    return std::get<27>(variant_);
  }

  void set_as_complex(ComplexValue def) {
    variant_.emplace<27>(std::move(def));
    tag_ = Tag::AS_COMPLEX;
  }

  friend void to_json(nlohmann::json& nlohmann_json_j, const Argument& nlohmann_json_t) {

    if (nlohmann_json_t.tag_ == Tag::AS_NONE) {
      nlohmann_json_j["as_none"] = nlohmann_json_t.get_as_none();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_TENSOR) {
      nlohmann_json_j["as_tensor"] = nlohmann_json_t.get_as_tensor();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_TENSORS) {
      nlohmann_json_j["as_tensors"] = nlohmann_json_t.get_as_tensors();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_INT) {
      nlohmann_json_j["as_int"] = nlohmann_json_t.get_as_int();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_INTS) {
      nlohmann_json_j["as_ints"] = nlohmann_json_t.get_as_ints();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_FLOAT) {
      nlohmann_json_j["as_float"] = nlohmann_json_t.get_as_float();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_FLOATS) {
      nlohmann_json_j["as_floats"] = nlohmann_json_t.get_as_floats();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_STRING) {
      nlohmann_json_j["as_string"] = nlohmann_json_t.get_as_string();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_STRINGS) {
      nlohmann_json_j["as_strings"] = nlohmann_json_t.get_as_strings();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_SYM_INT) {
      nlohmann_json_j["as_sym_int"] = nlohmann_json_t.get_as_sym_int();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_SYM_INTS) {
      nlohmann_json_j["as_sym_ints"] = nlohmann_json_t.get_as_sym_ints();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_SCALAR_TYPE) {
      nlohmann_json_j["as_scalar_type"] = nlohmann_json_t.get_as_scalar_type();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_MEMORY_FORMAT) {
      nlohmann_json_j["as_memory_format"] = nlohmann_json_t.get_as_memory_format();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_LAYOUT) {
      nlohmann_json_j["as_layout"] = nlohmann_json_t.get_as_layout();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_DEVICE) {
      nlohmann_json_j["as_device"] = nlohmann_json_t.get_as_device();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_BOOL) {
      nlohmann_json_j["as_bool"] = nlohmann_json_t.get_as_bool();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_BOOLS) {
      nlohmann_json_j["as_bools"] = nlohmann_json_t.get_as_bools();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_SYM_BOOL) {
      nlohmann_json_j["as_sym_bool"] = nlohmann_json_t.get_as_sym_bool();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_SYM_BOOLS) {
      nlohmann_json_j["as_sym_bools"] = nlohmann_json_t.get_as_sym_bools();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_GRAPH) {
      nlohmann_json_j["as_graph"] = nlohmann_json_t.get_as_graph();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_OPTIONAL_TENSORS) {
      nlohmann_json_j["as_optional_tensors"] = nlohmann_json_t.get_as_optional_tensors();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_CUSTOM_OBJ) {
      nlohmann_json_j["as_custom_obj"] = nlohmann_json_t.get_as_custom_obj();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_OPERATOR) {
      nlohmann_json_j["as_operator"] = nlohmann_json_t.get_as_operator();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_SYM_FLOAT) {
      nlohmann_json_j["as_sym_float"] = nlohmann_json_t.get_as_sym_float();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_SYM_FLOATS) {
      nlohmann_json_j["as_sym_floats"] = nlohmann_json_t.get_as_sym_floats();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_OPTIONAL_TENSOR) {
      nlohmann_json_j["as_optional_tensor"] = nlohmann_json_t.get_as_optional_tensor();
      return;
    }
    if (nlohmann_json_t.tag_ == Tag::AS_COMPLEX) {
      nlohmann_json_j["as_complex"] = nlohmann_json_t.get_as_complex();
      return;
    }
  }

  friend void from_json(const nlohmann::json& nlohmann_json_j, Argument& nlohmann_json_t) {

    if (nlohmann_json_j.contains("as_none")) {
      nlohmann_json_t.variant_.emplace<1>(nlohmann_json_j.at("as_none").template get<bool>());
      nlohmann_json_t.tag_ = Tag::AS_NONE;
      return;
    }
    if (nlohmann_json_j.contains("as_tensor")) {
      nlohmann_json_t.variant_.emplace<2>(nlohmann_json_j.at("as_tensor").template get<TensorArgument>());
      nlohmann_json_t.tag_ = Tag::AS_TENSOR;
      return;
    }
    if (nlohmann_json_j.contains("as_tensors")) {
      nlohmann_json_t.variant_.emplace<3>(nlohmann_json_j.at("as_tensors").template get<std::vector<TensorArgument>>());
      nlohmann_json_t.tag_ = Tag::AS_TENSORS;
      return;
    }
    if (nlohmann_json_j.contains("as_int")) {
      nlohmann_json_t.variant_.emplace<4>(nlohmann_json_j.at("as_int").template get<int64_t>());
      nlohmann_json_t.tag_ = Tag::AS_INT;
      return;
    }
    if (nlohmann_json_j.contains("as_ints")) {
      nlohmann_json_t.variant_.emplace<5>(nlohmann_json_j.at("as_ints").template get<std::vector<int64_t>>());
      nlohmann_json_t.tag_ = Tag::AS_INTS;
      return;
    }
    if (nlohmann_json_j.contains("as_float")) {
      nlohmann_json_t.variant_.emplace<6>(nlohmann_json_j.at("as_float").template get<F64>());
      nlohmann_json_t.tag_ = Tag::AS_FLOAT;
      return;
    }
    if (nlohmann_json_j.contains("as_floats")) {
      nlohmann_json_t.variant_.emplace<7>(nlohmann_json_j.at("as_floats").template get<std::vector<F64>>());
      nlohmann_json_t.tag_ = Tag::AS_FLOATS;
      return;
    }
    if (nlohmann_json_j.contains("as_string")) {
      nlohmann_json_t.variant_.emplace<8>(nlohmann_json_j.at("as_string").template get<std::string>());
      nlohmann_json_t.tag_ = Tag::AS_STRING;
      return;
    }
    if (nlohmann_json_j.contains("as_strings")) {
      nlohmann_json_t.variant_.emplace<9>(nlohmann_json_j.at("as_strings").template get<std::vector<std::string>>());
      nlohmann_json_t.tag_ = Tag::AS_STRINGS;
      return;
    }
    if (nlohmann_json_j.contains("as_sym_int")) {
      nlohmann_json_t.variant_.emplace<10>(nlohmann_json_j.at("as_sym_int").template get<SymIntArgument>());
      nlohmann_json_t.tag_ = Tag::AS_SYM_INT;
      return;
    }
    if (nlohmann_json_j.contains("as_sym_ints")) {
      nlohmann_json_t.variant_.emplace<11>(nlohmann_json_j.at("as_sym_ints").template get<std::vector<SymIntArgument>>());
      nlohmann_json_t.tag_ = Tag::AS_SYM_INTS;
      return;
    }
    if (nlohmann_json_j.contains("as_scalar_type")) {
      nlohmann_json_t.variant_.emplace<12>(nlohmann_json_j.at("as_scalar_type").template get<ScalarType>());
      nlohmann_json_t.tag_ = Tag::AS_SCALAR_TYPE;
      return;
    }
    if (nlohmann_json_j.contains("as_memory_format")) {
      nlohmann_json_t.variant_.emplace<13>(nlohmann_json_j.at("as_memory_format").template get<MemoryFormat>());
      nlohmann_json_t.tag_ = Tag::AS_MEMORY_FORMAT;
      return;
    }
    if (nlohmann_json_j.contains("as_layout")) {
      nlohmann_json_t.variant_.emplace<14>(nlohmann_json_j.at("as_layout").template get<Layout>());
      nlohmann_json_t.tag_ = Tag::AS_LAYOUT;
      return;
    }
    if (nlohmann_json_j.contains("as_device")) {
      nlohmann_json_t.variant_.emplace<15>(nlohmann_json_j.at("as_device").template get<Device>());
      nlohmann_json_t.tag_ = Tag::AS_DEVICE;
      return;
    }
    if (nlohmann_json_j.contains("as_bool")) {
      nlohmann_json_t.variant_.emplace<16>(nlohmann_json_j.at("as_bool").template get<bool>());
      nlohmann_json_t.tag_ = Tag::AS_BOOL;
      return;
    }
    if (nlohmann_json_j.contains("as_bools")) {
      nlohmann_json_t.variant_.emplace<17>(nlohmann_json_j.at("as_bools").template get<std::vector<bool>>());
      nlohmann_json_t.tag_ = Tag::AS_BOOLS;
      return;
    }
    if (nlohmann_json_j.contains("as_sym_bool")) {
      nlohmann_json_t.variant_.emplace<18>(nlohmann_json_j.at("as_sym_bool").template get<SymBoolArgument>());
      nlohmann_json_t.tag_ = Tag::AS_SYM_BOOL;
      return;
    }
    if (nlohmann_json_j.contains("as_sym_bools")) {
      nlohmann_json_t.variant_.emplace<19>(nlohmann_json_j.at("as_sym_bools").template get<std::vector<SymBoolArgument>>());
      nlohmann_json_t.tag_ = Tag::AS_SYM_BOOLS;
      return;
    }
    if (nlohmann_json_j.contains("as_graph")) {
      nlohmann_json_t.variant_.emplace<20>(nlohmann_json_j.at("as_graph").template get<GraphArgument>());
      nlohmann_json_t.tag_ = Tag::AS_GRAPH;
      return;
    }
    if (nlohmann_json_j.contains("as_optional_tensors")) {
      nlohmann_json_t.variant_.emplace<21>(nlohmann_json_j.at("as_optional_tensors").template get<std::vector<OptionalTensorArgument>>());
      nlohmann_json_t.tag_ = Tag::AS_OPTIONAL_TENSORS;
      return;
    }
    if (nlohmann_json_j.contains("as_custom_obj")) {
      nlohmann_json_t.variant_.emplace<22>(nlohmann_json_j.at("as_custom_obj").template get<CustomObjArgument>());
      nlohmann_json_t.tag_ = Tag::AS_CUSTOM_OBJ;
      return;
    }
    if (nlohmann_json_j.contains("as_operator")) {
      nlohmann_json_t.variant_.emplace<23>(nlohmann_json_j.at("as_operator").template get<std::string>());
      nlohmann_json_t.tag_ = Tag::AS_OPERATOR;
      return;
    }
    if (nlohmann_json_j.contains("as_sym_float")) {
      nlohmann_json_t.variant_.emplace<24>(nlohmann_json_j.at("as_sym_float").template get<SymFloatArgument>());
      nlohmann_json_t.tag_ = Tag::AS_SYM_FLOAT;
      return;
    }
    if (nlohmann_json_j.contains("as_sym_floats")) {
      nlohmann_json_t.variant_.emplace<25>(nlohmann_json_j.at("as_sym_floats").template get<std::vector<SymFloatArgument>>());
      nlohmann_json_t.tag_ = Tag::AS_SYM_FLOATS;
      return;
    }
    if (nlohmann_json_j.contains("as_optional_tensor")) {
      nlohmann_json_t.variant_.emplace<26>(nlohmann_json_j.at("as_optional_tensor").template get<OptionalTensorArgument>());
      nlohmann_json_t.tag_ = Tag::AS_OPTIONAL_TENSOR;
      return;
    }
    if (nlohmann_json_j.contains("as_complex")) {
      nlohmann_json_t.variant_.emplace<27>(nlohmann_json_j.at("as_complex").template get<ComplexValue>());
      nlohmann_json_t.tag_ = Tag::AS_COMPLEX;
      return;
    }
  }
};

inline std::string_view printEnum(const Argument::Tag& e) {
  switch (e) {
    case Argument::Tag::AS_NONE: return "AS_NONE";
    case Argument::Tag::AS_TENSOR: return "AS_TENSOR";
    case Argument::Tag::AS_TENSORS: return "AS_TENSORS";
    case Argument::Tag::AS_INT: return "AS_INT";
    case Argument::Tag::AS_INTS: return "AS_INTS";
    case Argument::Tag::AS_FLOAT: return "AS_FLOAT";
    case Argument::Tag::AS_FLOATS: return "AS_FLOATS";
    case Argument::Tag::AS_STRING: return "AS_STRING";
    case Argument::Tag::AS_STRINGS: return "AS_STRINGS";
    case Argument::Tag::AS_SYM_INT: return "AS_SYM_INT";
    case Argument::Tag::AS_SYM_INTS: return "AS_SYM_INTS";
    case Argument::Tag::AS_SCALAR_TYPE: return "AS_SCALAR_TYPE";
    case Argument::Tag::AS_MEMORY_FORMAT: return "AS_MEMORY_FORMAT";
    case Argument::Tag::AS_LAYOUT: return "AS_LAYOUT";
    case Argument::Tag::AS_DEVICE: return "AS_DEVICE";
    case Argument::Tag::AS_BOOL: return "AS_BOOL";
    case Argument::Tag::AS_BOOLS: return "AS_BOOLS";
    case Argument::Tag::AS_SYM_BOOL: return "AS_SYM_BOOL";
    case Argument::Tag::AS_SYM_BOOLS: return "AS_SYM_BOOLS";
    case Argument::Tag::AS_GRAPH: return "AS_GRAPH";
    case Argument::Tag::AS_OPTIONAL_TENSORS: return
```



## High-Level Overview

This file is part of the PyTorch framework located at `docs/torch/csrc/utils`.

## Detailed Analysis

### Code Structure


*For complete code details, see the Original Source section above.*


## Architecture & Design

### Role in PyTorch Architecture

This file is located in `docs/torch/csrc/utils`, which is part of the **core PyTorch library**.



## Dependencies

### Import Dependencies

*Dependency analysis not applicable for this file type.*


## Code Patterns & Idioms

### Common Patterns

*No specific patterns automatically detected.*


## Performance Considerations

### Performance Notes

- Contains **benchmarking** code or performance tests.

*Detailed performance analysis requires profiling and benchmarking.*


## Security & Safety

### Security Considerations

- **Serialization**: Uses pickle - be cautious with untrusted data

*Manual security review is recommended for production code.*


## Testing & Usage

### Testing

Test files for this module may be located in the `test/` directory.

### Usage Examples

*See the source code and related test files for usage examples.*


## Related Files

### Related Files

Files in the same folder (`docs/torch/csrc/utils`):

- [`python_tuples.h_kw.md_docs.md`](./python_tuples.h_kw.md_docs.md)
- [`six.h_kw.md_docs.md`](./six.h_kw.md_docs.md)
- [`tensor_types.cpp_docs.md_docs.md`](./tensor_types.cpp_docs.md_docs.md)
- [`tensor_list.h_kw.md_docs.md`](./tensor_list.h_kw.md_docs.md)
- [`verbose.h_kw.md_docs.md`](./verbose.h_kw.md_docs.md)
- [`invalid_arguments.cpp_kw.md_docs.md`](./invalid_arguments.cpp_kw.md_docs.md)
- [`tensor_apply.h_kw.md_docs.md`](./tensor_apply.h_kw.md_docs.md)
- [`cuda_enabled.h_docs.md_docs.md`](./cuda_enabled.h_docs.md_docs.md)
- [`tensor_layouts.h_docs.md_docs.md`](./tensor_layouts.h_docs.md_docs.md)
- [`variadic.h_kw.md_docs.md`](./variadic.h_kw.md_docs.md)


## Cross-References

- **File Documentation**: `generated_serialization_types.h_docs.md_docs.md`
- **Keyword Index**: `generated_serialization_types.h_docs.md_kw.md`
- **Folder Index**: `index.md`
- **Folder Documentation**: `doc.md`

---

*Generated by PyTorch Repository Documentation System*
