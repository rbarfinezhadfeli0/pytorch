# Documentation: eliminate_no_ops.cpp

## File Metadata
- **Path**: `torch/csrc/jit/passes/eliminate_no_ops.cpp`
- **Size**: 1939 bytes
- **Lines**: 78
- **Extension**: .cpp
- **Type**: Regular file

## Original Source

```cpp
#include <torch/csrc/jit/passes/eliminate_no_ops.h>

#include <torch/csrc/jit/jit_log.h>
#include <torch/csrc/jit/passes/dead_code_elimination.h>
#include <torch/csrc/jit/runtime/graph_iterator.h>

namespace torch::jit {

namespace {

bool allInputsAreTensors(Node* node) {
  for (const auto* value : node->inputs()) {
    const auto& type = value->type();
    if (!type->castRaw<TensorType>()) {
      return false;
    }
  }
  return true;
}

bool cannotOptimize(Node* node) {
  const auto kind = node->kind();
  if (kind == aten::__is__ || kind == aten::__isnot__) {
    return allInputsAreTensors(node);
  }
  return false;
}

// Certain ops can make this optimization unsound. For example,
// consider the following graph:
//   %y : Tensor = aten::detach(%x)
//   %b : bool = aten::__is__(%y, %x) (= False)
// After remove detach, we would get
//   %b : bool = aten::__is__(%x, %x) (= True!)
bool containsInvalidOp(std::shared_ptr<Graph>& graph) {
  for (auto* node : graph->nodes()) {
    if (cannotOptimize(node)) {
      return true;
    }
  }
  return false;
}

} // namespace

bool EliminateNoOps(
    std::shared_ptr<Graph>& graph,
    std::unordered_set<c10::Symbol> custom_ops) {
  GRAPH_DUMP("Before EliminateNoOps: ", graph);
  if (containsInvalidOp(graph)) {
    return false;
  }
  // Ops here should be of the form x = f(x, ...)
  std::unordered_set<c10::Symbol> no_ops{aten::detach};
  no_ops.insert(custom_ops.begin(), custom_ops.end());

  bool changed = false;

  auto graph_it = DepthFirstGraphNodeIterator(graph);
  for (auto* node = graph_it.next(); node != nullptr; node = graph_it.next()) {
    auto it = no_ops.find(node->kind());
    if (it == no_ops.end()) {
      continue;
    }

    changed = true;
    node->output()->replaceAllUsesWith(node->input(0));
  }

  if (changed) {
    EliminateDeadCode(graph);
  }

  GRAPH_DUMP("After EliminateNoOps: ", graph);
  return changed;
}

} // namespace torch::jit

```

## High-Level Overview

This file is part of the PyTorch repository. It is a C++/CUDA source/header file that may contain implementations, declarations, or kernel code.

## Detailed Walkthrough


## Key Components

The file contains 217 words across 78 lines of code/text.

## Usage & Examples

This file is part of the larger PyTorch codebase. For usage examples, refer to related test files and documentation.

## Performance & Security Notes

- File size: 1939 bytes
- Complexity: Standard

## Related Files

See the folder index for related files in the same directory.

## Testing

Refer to the PyTorch test suite for test coverage of this file.

---
*Generated by Repo Book Generator v1.0*
