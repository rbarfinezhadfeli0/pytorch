# Documentation: `torch/csrc/jit/serialization/mobile_bytecode_generated.h`

## File Metadata

- **Path**: `torch/csrc/jit/serialization/mobile_bytecode_generated.h`
- **Size**: 98,610 bytes (96.30 KB)
- **Type**: C/C++ Header File
- **Extension**: `.h`

## File Purpose

This is a c/c++ header file that is part of the PyTorch project.

## Original Source

```c
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MOBILEBYTECODE_TORCH_JIT_MOBILE_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_MOBILEBYTECODE_TORCH_JIT_MOBILE_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace torch {
namespace jit {
namespace mobile {
namespace serialization {

struct Int;

struct Bool;

struct Double;

struct PerTensorAffineSchema;

struct QuantizedSchema;
struct QuantizedSchemaBuilder;

struct TensorMetadata;
struct TensorMetadataBuilder;

struct String;
struct StringBuilder;

struct Device;
struct DeviceBuilder;

struct List;
struct ListBuilder;

struct IntList;
struct IntListBuilder;

struct DoubleList;
struct DoubleListBuilder;

struct BoolList;
struct BoolListBuilder;

struct Tuple;
struct TupleBuilder;

struct Dict;
struct DictBuilder;

struct ObjectType;
struct ObjectTypeBuilder;

struct Object;
struct ObjectBuilder;

struct ComplexDouble;

struct EnumValue;
struct EnumValueBuilder;

struct Instruction;

struct Operator;
struct OperatorBuilder;

struct Arg;
struct ArgBuilder;

struct Schema;
struct SchemaBuilder;

struct DebugInfo;
struct DebugInfoBuilder;

struct Function;
struct FunctionBuilder;

struct StorageData;
struct StorageDataBuilder;

struct IValue;
struct IValueBuilder;

struct ExtraFile;
struct ExtraFileBuilder;

struct Module;
struct ModuleBuilder;

enum class TypeType : uint8_t {
  UNSET = 0,
  CLASS_WITH_FIELD = 1,
  CUSTOM_CLASS = 2,
  CLASS_WITH_SETSTATE = 3,
  NON_OBJ = 4,
  MIN = UNSET,
  MAX = NON_OBJ
};

inline const TypeType (&EnumValuesTypeType())[5] {
  static const TypeType values[] = {
    TypeType::UNSET,
    TypeType::CLASS_WITH_FIELD,
    TypeType::CUSTOM_CLASS,
    TypeType::CLASS_WITH_SETSTATE,
    TypeType::NON_OBJ
  };
  return values;
}

inline const char * const *EnumNamesTypeType() {
  static const char * const names[6] = {
    "UNSET",
    "CLASS_WITH_FIELD",
    "CUSTOM_CLASS",
    "CLASS_WITH_SETSTATE",
    "NON_OBJ",
    nullptr
  };
  return names;
}

inline const char *EnumNameTypeType(TypeType e) {
  if (::flatbuffers::IsOutRange(e, TypeType::UNSET, TypeType::NON_OBJ)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTypeType()[index];
}

enum class IValueUnion : uint8_t {
  NONE = 0,
  Int = 1,
  Bool = 2,
  Double = 3,
  ComplexDouble = 4,
  TensorMetadata = 5,
  String = 6,
  List = 7,
  Tuple = 8,
  Dict = 9,
  Object = 10,
  IntList = 11,
  DoubleList = 12,
  BoolList = 13,
  Device = 14,
  EnumValue = 15,
  Function = 16,
  MIN = NONE,
  MAX = Function
};

inline const IValueUnion (&EnumValuesIValueUnion())[17] {
  static const IValueUnion values[] = {
    IValueUnion::NONE,
    IValueUnion::Int,
    IValueUnion::Bool,
    IValueUnion::Double,
    IValueUnion::ComplexDouble,
    IValueUnion::TensorMetadata,
    IValueUnion::String,
    IValueUnion::List,
    IValueUnion::Tuple,
    IValueUnion::Dict,
    IValueUnion::Object,
    IValueUnion::IntList,
    IValueUnion::DoubleList,
    IValueUnion::BoolList,
    IValueUnion::Device,
    IValueUnion::EnumValue,
    IValueUnion::Function
  };
  return values;
}

inline const char * const *EnumNamesIValueUnion() {
  static const char * const names[18] = {
    "NONE",
    "Int",
    "Bool",
    "Double",
    "ComplexDouble",
    "TensorMetadata",
    "String",
    "List",
    "Tuple",
    "Dict",
    "Object",
    "IntList",
    "DoubleList",
    "BoolList",
    "Device",
    "EnumValue",
    "Function",
    nullptr
  };
  return names;
}

inline const char *EnumNameIValueUnion(IValueUnion e) {
  if (::flatbuffers::IsOutRange(e, IValueUnion::NONE, IValueUnion::Function)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIValueUnion()[index];
}

template<typename T> struct IValueUnionTraits {
  static const IValueUnion enum_value = IValueUnion::NONE;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::Int> {
  static const IValueUnion enum_value = IValueUnion::Int;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::Bool> {
  static const IValueUnion enum_value = IValueUnion::Bool;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::Double> {
  static const IValueUnion enum_value = IValueUnion::Double;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::ComplexDouble> {
  static const IValueUnion enum_value = IValueUnion::ComplexDouble;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::TensorMetadata> {
  static const IValueUnion enum_value = IValueUnion::TensorMetadata;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::String> {
  static const IValueUnion enum_value = IValueUnion::String;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::List> {
  static const IValueUnion enum_value = IValueUnion::List;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::Tuple> {
  static const IValueUnion enum_value = IValueUnion::Tuple;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::Dict> {
  static const IValueUnion enum_value = IValueUnion::Dict;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::Object> {
  static const IValueUnion enum_value = IValueUnion::Object;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::IntList> {
  static const IValueUnion enum_value = IValueUnion::IntList;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::DoubleList> {
  static const IValueUnion enum_value = IValueUnion::DoubleList;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::BoolList> {
  static const IValueUnion enum_value = IValueUnion::BoolList;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::Device> {
  static const IValueUnion enum_value = IValueUnion::Device;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::EnumValue> {
  static const IValueUnion enum_value = IValueUnion::EnumValue;
};

template<> struct IValueUnionTraits<torch::jit::mobile::serialization::Function> {
  static const IValueUnion enum_value = IValueUnion::Function;
};

bool VerifyIValueUnion(::flatbuffers::Verifier &verifier, const void *obj, IValueUnion type);
bool VerifyIValueUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<IValueUnion> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Int FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t int_val_;

 public:
  Int()
      : int_val_(0) {
  }
  Int(int64_t _int_val)
      : int_val_(::flatbuffers::EndianScalar(_int_val)) {
  }
  int64_t int_val() const {
    return ::flatbuffers::EndianScalar(int_val_);
  }
  void mutate_int_val(int64_t _int_val) {
    ::flatbuffers::WriteScalar(&int_val_, _int_val);
  }
};
FLATBUFFERS_STRUCT_END(Int, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Bool FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bool_val_;

 public:
  Bool()
      : bool_val_(0) {
  }
  Bool(bool _bool_val)
      : bool_val_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_bool_val))) {
  }
  bool bool_val() const {
    return ::flatbuffers::EndianScalar(bool_val_) != 0;
  }
  void mutate_bool_val(bool _bool_val) {
    ::flatbuffers::WriteScalar(&bool_val_, static_cast<uint8_t>(_bool_val));
  }
};
FLATBUFFERS_STRUCT_END(Bool, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Double FLATBUFFERS_FINAL_CLASS {
 private:
  double double_val_;

 public:
  Double()
      : double_val_(0) {
  }
  Double(double _double_val)
      : double_val_(::flatbuffers::EndianScalar(_double_val)) {
  }
  double double_val() const {
    return ::flatbuffers::EndianScalar(double_val_);
  }
  void mutate_double_val(double _double_val) {
    ::flatbuffers::WriteScalar(&double_val_, _double_val);
  }
};
FLATBUFFERS_STRUCT_END(Double, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PerTensorAffineSchema FLATBUFFERS_FINAL_CLASS {
 private:
  double q_scale_;
  int32_t q_zero_point_;
  int32_t padding0__;

 public:
  PerTensorAffineSchema()
      : q_scale_(0),
        q_zero_point_(0),
        padding0__(0) {
    (void)padding0__;
  }
  PerTensorAffineSchema(double _q_scale, int32_t _q_zero_point)
      : q_scale_(::flatbuffers::EndianScalar(_q_scale)),
        q_zero_point_(::flatbuffers::EndianScalar(_q_zero_point)),
        padding0__(0) {
    (void)padding0__;
  }
  double q_scale() const {
    return ::flatbuffers::EndianScalar(q_scale_);
  }
  void mutate_q_scale(double _q_scale) {
    ::flatbuffers::WriteScalar(&q_scale_, _q_scale);
  }
  int32_t q_zero_point() const {
    return ::flatbuffers::EndianScalar(q_zero_point_);
  }
  void mutate_q_zero_point(int32_t _q_zero_point) {
    ::flatbuffers::WriteScalar(&q_zero_point_, _q_zero_point);
  }
};
FLATBUFFERS_STRUCT_END(PerTensorAffineSchema, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ComplexDouble FLATBUFFERS_FINAL_CLASS {
 private:
  double real_;
  double imag_;

 public:
  ComplexDouble()
      : real_(0),
        imag_(0) {
  }
  ComplexDouble(double _real, double _imag)
      : real_(::flatbuffers::EndianScalar(_real)),
        imag_(::flatbuffers::EndianScalar(_imag)) {
  }
  double real() const {
    return ::flatbuffers::EndianScalar(real_);
  }
  void mutate_real(double _real) {
    ::flatbuffers::WriteScalar(&real_, _real);
  }
  double imag() const {
    return ::flatbuffers::EndianScalar(imag_);
  }
  void mutate_imag(double _imag) {
    ::flatbuffers::WriteScalar(&imag_, _imag);
  }
};
FLATBUFFERS_STRUCT_END(ComplexDouble, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Instruction FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t op_;
  int8_t padding0__;
  uint16_t n_;
  int32_t x_;

 public:
  Instruction()
      : op_(0),
        padding0__(0),
        n_(0),
        x_(0) {
    (void)padding0__;
  }
  Instruction(int8_t _op, uint16_t _n, int32_t _x)
      : op_(::flatbuffers::EndianScalar(_op)),
        padding0__(0),
        n_(::flatbuffers::EndianScalar(_n)),
        x_(::flatbuffers::EndianScalar(_x)) {
    (void)padding0__;
  }
  int8_t op() const {
    return ::flatbuffers::EndianScalar(op_);
  }
  void mutate_op(int8_t _op) {
    ::flatbuffers::WriteScalar(&op_, _op);
  }
  uint16_t n() const {
    return ::flatbuffers::EndianScalar(n_);
  }
  void mutate_n(uint16_t _n) {
    ::flatbuffers::WriteScalar(&n_, _n);
  }
  int32_t x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(int32_t _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
};
FLATBUFFERS_STRUCT_END(Instruction, 8);

struct QuantizedSchema FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizedSchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QSCHEME = 4,
    VT_SCALE = 6,
    VT_ZERO_POINT = 8,
    VT_SCALES = 10,
    VT_ZERO_POINTS = 12,
    VT_AXIS = 14
  };
  int8_t qscheme() const {
    return GetField<int8_t>(VT_QSCHEME, 0);
  }
  bool mutate_qscheme(int8_t _qscheme = 0) {
    return SetField<int8_t>(VT_QSCHEME, _qscheme, 0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  bool mutate_scale(double _scale = 0.0) {
    return SetField<double>(VT_SCALE, _scale, 0.0);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  bool mutate_zero_point(int32_t _zero_point = 0) {
    return SetField<int32_t>(VT_ZERO_POINT, _zero_point, 0);
  }
  const torch::jit::mobile::serialization::TensorMetadata *scales() const {
    return GetPointer<const torch::jit::mobile::serialization::TensorMetadata *>(VT_SCALES);
  }
  torch::jit::mobile::serialization::TensorMetadata *mutable_scales() {
    return GetPointer<torch::jit::mobile::serialization::TensorMetadata *>(VT_SCALES);
  }
  const torch::jit::mobile::serialization::TensorMetadata *zero_points() const {
    return GetPointer<const torch::jit::mobile::serialization::TensorMetadata *>(VT_ZERO_POINTS);
  }
  torch::jit::mobile::serialization::TensorMetadata *mutable_zero_points() {
    return GetPointer<torch::jit::mobile::serialization::TensorMetadata *>(VT_ZERO_POINTS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis = 0) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_QSCHEME, 1) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, 4) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyTable(scales()) &&
           VerifyOffset(verifier, VT_ZERO_POINTS) &&
           verifier.VerifyTable(zero_points()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct QuantizedSchemaBuilder {
  typedef QuantizedSchema Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_qscheme(int8_t qscheme) {
    fbb_.AddElement<int8_t>(QuantizedSchema::VT_QSCHEME, qscheme, 0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(QuantizedSchema::VT_SCALE, scale, 0.0);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(QuantizedSchema::VT_ZERO_POINT, zero_point, 0);
  }
  void add_scales(::flatbuffers::Offset<torch::jit::mobile::serialization::TensorMetadata> scales) {
    fbb_.AddOffset(QuantizedSchema::VT_SCALES, scales);
  }
  void add_zero_points(::flatbuffers::Offset<torch::jit::mobile::serialization::TensorMetadata> zero_points) {
    fbb_.AddOffset(QuantizedSchema::VT_ZERO_POINTS, zero_points);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(QuantizedSchema::VT_AXIS, axis, 0);
  }
  explicit QuantizedSchemaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizedSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizedSchema>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizedSchema> CreateQuantizedSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t qscheme = 0,
    double scale = 0.0,
    int32_t zero_point = 0,
    ::flatbuffers::Offset<torch::jit::mobile::serialization::TensorMetadata> scales = 0,
    ::flatbuffers::Offset<torch::jit::mobile::serialization::TensorMetadata> zero_points = 0,
    int32_t axis = 0) {
  QuantizedSchemaBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_axis(axis);
  builder_.add_zero_points(zero_points);
  builder_.add_scales(scales);
  builder_.add_zero_point(zero_point);
  builder_.add_qscheme(qscheme);
  return builder_.Finish();
}

struct TensorMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STORAGE_LOCATION_INDEX = 4,
    VT_SCALAR_TYPE = 6,
    VT_STORAGE_OFFSET = 8,
    VT_SIZES = 10,
    VT_STRIDES = 12,
    VT_REQUIRES_GRAD = 14,
    VT_QUANTIZED_SCHEMA = 16
  };
  uint32_t storage_location_index() const {
    return GetField<uint32_t>(VT_STORAGE_LOCATION_INDEX, 0);
  }
  bool mutate_storage_location_index(uint32_t _storage_location_index = 0) {
    return SetField<uint32_t>(VT_STORAGE_LOCATION_INDEX, _storage_location_index, 0);
  }
  int8_t scalar_type() const {
    return GetField<int8_t>(VT_SCALAR_TYPE, 0);
  }
  bool mutate_scalar_type(int8_t _scalar_type = 0) {
    return SetField<int8_t>(VT_SCALAR_TYPE, _scalar_type, 0);
  }
  int32_t storage_offset() const {
    return GetField<int32_t>(VT_STORAGE_OFFSET, 0);
  }
  bool mutate_storage_offset(int32_t _storage_offset = 0) {
    return SetField<int32_t>(VT_STORAGE_OFFSET, _storage_offset, 0);
  }
  const ::flatbuffers::Vector<int32_t> *sizes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SIZES);
  }
  ::flatbuffers::Vector<int32_t> *mutable_sizes() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_SIZES);
  }
  const ::flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  ::flatbuffers::Vector<int32_t> *mutable_strides() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool requires_grad() const {
    return GetField<uint8_t>(VT_REQUIRES_GRAD, 0) != 0;
  }
  bool mutate_requires_grad(bool _requires_grad = 0) {
    return SetField<uint8_t>(VT_REQUIRES_GRAD, static_cast<uint8_t>(_requires_grad), 0);
  }
  const torch::jit::mobile::serialization::QuantizedSchema *quantized_schema() const {
    return GetPointer<const torch::jit::mobile::serialization::QuantizedSchema *>(VT_QUANTIZED_SCHEMA);
  }
  torch::jit::mobile::serialization::QuantizedSchema *mutable_quantized_schema() {
    return GetPointer<torch::jit::mobile::serialization::QuantizedSchema *>(VT_QUANTIZED_SCHEMA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STORAGE_LOCATION_INDEX, 4) &&
           VerifyField<int8_t>(verifier, VT_SCALAR_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_STORAGE_OFFSET, 4) &&
           VerifyOffset(verifier, VT_SIZES) &&
           verifier.VerifyVector(sizes()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRES_GRAD, 1) &&
           VerifyOffset(verifier, VT_QUANTIZED_SCHEMA) &&
           verifier.VerifyTable(quantized_schema()) &&
           verifier.EndTable();
  }
};

struct TensorMetadataBuilder {
  typedef TensorMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_storage_location_index(uint32_t storage_location_index) {
    fbb_.AddElement<uint32_t>(TensorMetadata::VT_STORAGE_LOCATION_INDEX, storage_location_index, 0);
  }
  void add_scalar_type(int8_t scalar_type) {
    fbb_.AddElement<int8_t>(TensorMetadata::VT_SCALAR_TYPE, scalar_type, 0);
  }
  void add_storage_offset(int32_t storage_offset) {
    fbb_.AddElement<int32_t>(TensorMetadata::VT_STORAGE_OFFSET, storage_offset, 0);
  }
  void add_sizes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> sizes) {
    fbb_.AddOffset(TensorMetadata::VT_SIZES, sizes);
  }
  void add_strides(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(TensorMetadata::VT_STRIDES, strides);
  }
  void add_requires_grad(bool requires_grad) {
    fbb_.AddElement<uint8_t>(TensorMetadata::VT_REQUIRES_GRAD, static_cast<uint8_t>(requires_grad), 0);
  }
  void add_quantized_schema(::flatbuffers::Offset<torch::jit::mobile::serialization::QuantizedSchema> quantized_schema) {
    fbb_.AddOffset(TensorMetadata::VT_QUANTIZED_SCHEMA, quantized_schema);
  }
  explicit TensorMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorMetadata> CreateTensorMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t storage_location_index = 0,
    int8_t scalar_type = 0,
    int32_t storage_offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> sizes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides = 0,
    bool requires_grad = false,
    ::flatbuffers::Offset<torch::jit::mobile::serialization::QuantizedSchema> quantized_schema = 0) {
  TensorMetadataBuilder builder_(_fbb);
  builder_.add_quantized_schema(quantized_schema);
  builder_.add_strides(strides);
  builder_.add_sizes(sizes);
  builder_.add_storage_offset(storage_offset);
  builder_.add_storage_location_index(storage_location_index);
  builder_.add_requires_grad(requires_grad);
  builder_.add_scalar_type(scalar_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorMetadata> CreateTensorMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t storage_location_index = 0,
    int8_t scalar_type = 0,
    int32_t storage_offset = 0,
    const std::vector<int32_t> *sizes = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    bool requires_grad = false,
    ::flatbuffers::Offset<torch::jit::mobile::serialization::QuantizedSchema> quantized_schema = 0) {
  auto sizes__ = sizes ? _fbb.CreateVector<int32_t>(*sizes) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return torch::jit::mobile::serialization::CreateTensorMetadata(
      _fbb,
      storage_location_index,
      scalar_type,
      storage_offset,
      sizes__,
      strides__,
      requires_grad,
      quantized_schema);
}

struct String FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  ::flatbuffers::String *mutable_data() {
    return GetPointer<::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(String::VT_DATA, data);
  }
  explicit StringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<String>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<String> CreateString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<String> CreateStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return torch::jit::mobile::serialization::CreateString(
      _fbb,
      data__);
}

struct Device FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeviceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STR = 4
  };
  const ::flatbuffers::String *str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STR);
  }
  ::flatbuffers::String *mutable_str() {
    return GetPointer<::flatbuffers::String *>(VT_STR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.VerifyString(str()) &&
           verifier.EndTable();
  }
};

struct DeviceBuilder {
  typedef Device Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_str(::flatbuffers::Offset<::flatbuffers::String> str) {
    fbb_.AddOffset(Device::VT_STR, str);
  }
  explicit DeviceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Device> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Device>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Device> CreateDevice(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> str = 0) {
  DeviceBuilder builder_(_fbb);
  builder_.add_str(str);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Device> CreateDeviceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *str = nullptr) {
  auto str__ = str ? _fbb.CreateString(str) : 0;
  return torch::jit::mobile::serialization::CreateDevice(
      _fbb,
      str__);
}

struct List FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4,
    VT_ANNOTATION_STR = 6
  };
  const ::flatbuffers::Vector<uint32_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  const ::flatbuffers::String *annotation_str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANNOTATION_STR);
  }
  ::flatbuffers::String *mutable_annotation_str() {
    return GetPointer<::flatbuffers::String *>(VT_ANNOTATION_STR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           VerifyOffset(verifier, VT_ANNOTATION_STR) &&
           verifier.VerifyString(annotation_str()) &&
           verifier.EndTable();
  }
};

struct ListBuilder {
  typedef List Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> items) {
    fbb_.AddOffset(List::VT_ITEMS, items);
  }
  void add_annotation_str(::flatbuffers::Offset<::flatbuffers::String> annotation_str) {
    fbb_.AddOffset(List::VT_ANNOTATION_STR, annotation_str);
  }
  explicit ListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<List> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<List>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<List> CreateList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> items = 0,
    ::flatbuffers::Offset<::flatbuffers::String> annotation_str = 0) {
  ListBuilder builder_(_fbb);
  builder_.add_annotation_str(annotation_str);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<List> CreateListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *items = nullptr,
    const char *annotation_str = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint32_t>(*items) : 0;
  auto annotation_str__ = annotation_str ? _fbb.CreateString(annotation_str) : 0;
  return torch::jit::mobile::serialization::CreateList(
      _fbb,
      items__,
      annotation_str__);
}

struct IntList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<int64_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct IntListBuilder {
  typedef IntList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> items) {
    fbb_.AddOffset(IntList::VT_ITEMS, items);
  }
  explicit IntListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntList> CreateIntList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> items = 0) {
  IntListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntList> CreateIntListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<int64_t>(*items) : 0;
  return torch::jit::mobile::serialization::CreateIntList(
      _fbb,
      items__);
}

struct DoubleList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<double> *items() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<double> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct DoubleListBuilder {
  typedef DoubleList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<double>> items) {
    fbb_.AddOffset(DoubleList::VT_ITEMS, items);
  }
  explicit DoubleListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DoubleList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DoubleList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DoubleList> CreateDoubleList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> items = 0) {
  DoubleListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DoubleList> CreateDoubleListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<double>(*items) : 0;
  return torch::jit::mobile::serialization::CreateDoubleList(
      _fbb,
      items__);
}

struct BoolList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct BoolListBuilder {
  typedef BoolList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(BoolList::VT_ITEMS, items);
  }
  explicit BoolListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolList> CreateBoolList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> items = 0) {
  BoolListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BoolList> CreateBoolListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return torch::jit::mobile::serialization::CreateBoolList(
      _fbb,
      items__);
}

struct Tuple FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TupleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<uint32_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  typedef Tuple Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> items) {
    fbb_.AddOffset(Tuple::VT_ITEMS, items);
  }
  explicit TupleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tuple> CreateTuple(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> items = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tuple> CreateTupleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint32_t>(*items) : 0;
  return torch::jit::mobile::serialization::CreateTuple(
      _fbb,
      items__);
}

struct Dict FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DictBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_VALUES = 6,
    VT_ANNOTATION_STR = 8
  };
  const ::flatbuffers::Vector<uint32_t> *keys() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_KEYS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_keys() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_KEYS);
  }
  const ::flatbuffers::Vector<uint32_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_VALUES);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_values() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_VALUES);
  }
  const ::flatbuffers::String *annotation_str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANNOTATION_STR);
  }
  ::flatbuffers::String *mutable_annotation_str() {
    return GetPointer<::flatbuffers::String *>(VT_ANNOTATION_STR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifyOffset(verifier, VT_ANNOTATION_STR) &&
           verifier.VerifyString(annotation_str()) &&
           verifier.EndTable();
  }
};

struct DictBuilder {
  typedef Dict Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_keys(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> keys) {
    fbb_.AddOffset(Dict::VT_KEYS, keys);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> values) {
    fbb_.AddOffset(Dict::VT_VALUES, values);
  }
  void add_annotation_str(::flatbuffers::Offset<::flatbuffers::String> annotation_str) {
    fbb_.AddOffset(Dict::VT_ANNOTATION_STR, annotation_str);
  }
  explicit DictBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dict> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dict>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Dict> CreateDict(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> keys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> values = 0,
    ::flatbuffers::Offset<::flatbuffers::String> annotation_str = 0) {
  DictBuilder builder_(_fbb);
  builder_.add_annotation_str(annotation_str);
  builder_.add_values(values);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Dict> CreateDictDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *keys = nullptr,
    const std::vector<uint32_t> *values = nullptr,
    const char *annotation_str = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<uint32_t>(*keys) : 0;
  auto values__ = values ? _fbb.CreateVector<uint32_t>(*values) : 0;
  auto annotation_str__ = annotation_str ? _fbb.CreateString(annotation_str) : 0;
  return torch::jit::mobile::serialization::CreateDict(
      _fbb,
      keys__,
      values__,
      annotation_str__);
}

struct ObjectType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_NAME = 4,
    VT_TYPE = 6,
    VT_ATTR_NAMES = 8
  };
  const ::flatbuffers::String *type_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE_NAME);
  }
  ::flatbuffers::String *mutable_type_name() {
    return GetPointer<::flatbuffers::String *>(VT_TYPE_NAME);
  }
  torch::jit::mobile::serialization::TypeType type() const {
    return static_cast<torch::jit::mobile::serialization::TypeType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(torch::jit::mobile::serialization::TypeType _type = static_cast<torch::jit::mobile::serialization::TypeType>(0)) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *attr_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ATTR_NAMES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_attr_names() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ATTR_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE_NAME) &&
           verifier.VerifyString(type_name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_ATTR_NAMES) &&
           verifier.VerifyVector(attr_names()) &&
           verifier.VerifyVectorOfStrings(attr_names()) &&
           verifier.EndTable();
  }
};

struct ObjectTypeBuilder {
  typedef ObjectType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type_name(::flatbuffers::Offset<::flatbuffers::String> type_name) {
    fbb_.AddOffset(ObjectType::VT_TYPE_NAME, type_name);
  }
  void add_type(torch::jit::mobile::serialization::TypeType type) {
    fbb_.AddElement<uint8_t>(ObjectType::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_attr_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> attr_names) {
    fbb_.AddOffset(ObjectType::VT_ATTR_NAMES, attr_names);
  }
  explicit ObjectTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectType> CreateObjectType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type_name = 0,
    torch::jit::mobile::serialization::TypeType type = torch::jit::mobile::serialization::TypeType::UNSET,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> attr_names = 0) {
  ObjectTypeBuilder builder_(_fbb);
  builder_.add_attr_names(attr_names);
  builder_.add_type_name(type_name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectType> CreateObjectTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type_name = nullptr,
    torch::jit::mobile::serialization::TypeType type = torch::jit::mobile::serialization::TypeType::UNSET,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *attr_names = nullptr) {
  auto type_name__ = type_name ? _fbb.CreateString(type_name) : 0;
  auto attr_names__ = attr_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*attr_names) : 0;
  return torch::jit::mobile::serialization::CreateObjectType(
      _fbb,
      type_name__,
      type,
      attr_names__);
}

struct Object FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_INDEX = 4,
    VT_STATE = 6,
    VT_ATTRS = 8,
    VT_SETSTATE_FUNC = 10
  };
  uint32_t type_index() const {
    return GetField<uint32_t>(VT_TYPE_INDEX, 0);
  }
  bool mutate_type_index(uint32_t _type_index = 0) {
    return SetField<uint32_t>(VT_TYPE_INDEX, _type_index, 0);
  }
  uint32_t state() const {
    return GetField<uint32_t>(VT_STATE, 0);
  }
  bool mutate_state(uint32_t _state = 0) {
    return SetField<uint32_t>(VT_STATE, _state, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *attrs() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ATTRS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_attrs() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_ATTRS);
  }
  uint32_t setstate_func() const {
    return GetField<uint32_t>(VT_SETSTATE_FUNC, 0);
  }
  bool mutate_setstate_func(uint32_t _setstate_func = 0) {
    return SetField<uint32_t>(VT_SETSTATE_FUNC, _setstate_func, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TYPE_INDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_STATE, 4) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyVector(attrs()) &&
           VerifyField<uint32_t>(verifier, VT_SETSTATE_FUNC, 4) &&
           verifier.EndTable();
  }
};

struct ObjectBuilder {
  typedef Object Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type_index(uint32_t type_index) {
    fbb_.AddElement<uint32_t>(Object::VT_TYPE_INDEX, type_index, 0);
  }
  void add_state(uint32_t state) {
    fbb_.AddElement<uint32_t>(Object::VT_STATE, state, 0);
  }
  void add_attrs(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> attrs) {
    fbb_.AddOffset(Object::VT_ATTRS, attrs);
  }
  void add_setstate_func(uint32_t setstate_func) {
    fbb_.AddElement<uint32_t>(Object::VT_SETSTATE_FUNC, setstate_func, 0);
  }
  explicit ObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Object> CreateObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t type_index = 0,
    uint32_t state = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> attrs = 0,
    uint32_t setstate_func = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_setstate_func(setstate_func);
  builder_.add_attrs(attrs);
  builder_.add_state(state);
  builder_.add_type_index(type_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Object> CreateObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t type_index = 0,
    uint32_t state = 0,
    const std::vector<uint32_t> *attrs = nullptr,
    uint32_t setstate_func = 0) {
  auto attrs__ = attrs ? _fbb.CreateVector<uint32_t>(*attrs) : 0;
  return torch::jit::mobile::serialization::CreateObject(
      _fbb,
      type_index,
      state,
      attrs__,
      setstate_func);
}

struct EnumValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_NAME = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *type_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE_NAME);
  }
  ::flatbuffers::String *mutable_type_name() {
    return GetPointer<::flatbuffers::String *>(VT_TYPE_NAME);
  }
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint32_t _value = 0) {
    return SetField<uint32_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE_NAME) &&
           verifier.VerifyString(type_name()) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct EnumValueBuilder {
  typedef EnumValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type_name(::flatbuffers::Offset<::flatbuffers::String> type_name) {
    fbb_.AddOffset(EnumValue::VT_TYPE_NAME, type_name);
  }
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(EnumValue::VT_VALUE, value, 0);
  }
  explicit EnumValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumValue> CreateEnumValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type_name = 0,
    uint32_t value = 0) {
  EnumValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_type_name(type_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumValue> CreateEnumValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type_name = nullptr,
    uint32_t value = 0) {
  auto type_name__ = type_name ? _fbb.CreateString(type_name) : 0;
  return torch::jit::mobile::serialization::CreateEnumValue(
      _fbb,
      type_name__,
      value);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OVERLOAD_NAME = 6,
    VT_NUM_ARGS_SERIALIZED = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *overload_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OVERLOAD_NAME);
  }
  ::flatbuffers::String *mutable_overload_name() {
    return GetPointer<::flatbuffers::String *>(VT_OVERLOAD_NAME);
  }
  int32_t num_args_serialized() const {
    return GetField<int32_t>(VT_NUM_ARGS_SERIALIZED, -1);
  }
  bool mutate_num_args_serialized(int32_t _num_args_serialized = -1) {
    return SetField<int32_t>(VT_NUM_ARGS_SERIALIZED, _num_args_serialized, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OVERLOAD_NAME) &&
           verifier.VerifyString(overload_name()) &&
           VerifyField<int32_t>(verifier, VT_NUM_ARGS_SERIALIZED, 4) &&
           verifier.EndTable();
  }
};

struct OperatorBuilder {
  typedef Operator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Operator::VT_NAME, name);
  }
  void add_overload_name(::flatbuffers::Offset<::flatbuffers::String> overload_name) {
    fbb_.AddOffset(Operator::VT_OVERLOAD_NAME, overload_name);
  }
  void add_num_args_serialized(int32_t num_args_serialized) {
    fbb_.AddElement<int32_t>(Operator::VT_NUM_ARGS_SERIALIZED, num_args_serialized, -1);
  }
  explicit OperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Operator> CreateOperator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> overload_name = 0,
    int32_t num_args_serialized = -1) {
  OperatorBuilder builder_(_fbb);
  builder_.add_num_args_serialized(num_args_serialized);
  builder_.add_overload_name(overload_name);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Operator> CreateOperatorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *ove
```



## High-Level Overview


This C++ file contains approximately 2 class(es)/struct(s) and 267 function(s).

## Detailed Analysis

### Code Structure

**Namespaces**: `jit`, `mobile`, `torch`, `serialization`

**Classes/Structs**: `Int`, `Bool`, `Double`, `PerTensorAffineSchema`, `QuantizedSchema`, `QuantizedSchemaBuilder`, `TensorMetadata`, `TensorMetadataBuilder`, `String`, `StringBuilder`, `Device`, `DeviceBuilder`, `List`, `ListBuilder`, `IntList`, `IntListBuilder`, `DoubleList`, `DoubleListBuilder`, `BoolList`, `BoolListBuilder`


*For complete code details, see the Original Source section above.*


## Architecture & Design

### Role in PyTorch Architecture

This file is located in `torch/csrc/jit/serialization`, which is part of the **core PyTorch library**.



## Dependencies

### Import Dependencies

This file includes:

- `flatbuffers/flatbuffers.h`


## Code Patterns & Idioms

### Common Patterns

*No specific patterns automatically detected.*


## Performance Considerations

### Performance Notes

- May involve **JIT compilation** or compilation optimizations.

*Detailed performance analysis requires profiling and benchmarking.*


## Security & Safety

### Security Considerations

- No obvious security concerns detected in automated analysis.

*Manual security review is recommended for production code.*


## Testing & Usage

### Testing

Test files for this module may be located in the `test/` directory.

### Usage Examples

*See the source code and related test files for usage examples.*


## Related Files

### Related Files

Files in the same folder (`torch/csrc/jit/serialization`):

- [`import_read.h_docs.md`](./import_read.h_docs.md)
- [`unpickler.h_docs.md`](./unpickler.h_docs.md)
- [`import_export_functions.h_docs.md`](./import_export_functions.h_docs.md)
- [`import.h_docs.md`](./import.h_docs.md)
- [`pickle.cpp_docs.md`](./pickle.cpp_docs.md)
- [`source_range_serialization_impl.h_docs.md`](./source_range_serialization_impl.h_docs.md)
- [`import_export_helpers.cpp_docs.md`](./import_export_helpers.cpp_docs.md)
- [`import_export_constants.h_docs.md`](./import_export_constants.h_docs.md)
- [`source_range_serialization.h_docs.md`](./source_range_serialization.h_docs.md)


## Cross-References

- **File Documentation**: `mobile_bytecode_generated.h_docs.md`
- **Keyword Index**: `mobile_bytecode_generated.h_kw.md`
- **Folder Index**: `index.md`
- **Folder Documentation**: `doc.md`

---

*Generated by PyTorch Repository Documentation System*
